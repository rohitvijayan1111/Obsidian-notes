

1) Read the questions once, or twice until the problem is understood
2) Then go through the input range and to see the edges cases that i could miss
3) go through the test cases
4) dry run the test cases
5) think of the code
6) think of the breaking point of the code
7) then dry run the code
8) then see the time and space complexity


You're on the right track! What you've listed is a good start, but let's refine it into a **systematic, step-by-step framework** that will help you approach **coding problems efficiently and thoroughly**, especially in interviews or contests.

---

### ✅ **Ultimate Framework for Solving Coding Problems**

---

### 🔍 **Step 1: Understand the Problem Deeply**

- Read the problem at least **twice**.
    
- Make sure you can **restate the problem in your own words**.
    
- Ask:
    
    - What are the inputs and outputs?
        
    - Are there any constraints?
        
    - What exactly needs to be done?
        

---

### 📐 **Step 2: Analyze Constraints and Edge Cases**

- Look at input size:
    
    - Small inputs → brute-force may be okay.
        
    - Large inputs → needs optimization.
        
- Think of **edge cases**, such as:
    
    - Empty input
        
    - Single-element input
        
    - All values the same
        
    - Already sorted or completely reversed
        
    - Minimum and maximum values
        

✳️ **Tip:** Write down at least **3–5 edge cases** before coding.

---

### 🧪 **Step 3: Examine Given Test Cases (If Any)**

- Analyze what each test case is testing.
    
- Is it covering edge cases?
    
- Manually compute outputs for a few test cases.
    

---

### 🧠 **Step 4: Plan the Approach (High-Level)**

- Choose the right technique: Two-pointer? Recursion? DP? Greedy?
    
- Write pseudocode or a few comments outlining steps.
    
- Think about **data structures** that suit the problem.
    

---

### 🧱 **Step 5: Think Through Code Logic and Pitfalls**

- Before coding, **mentally trace your approach**.
    
- Think:
    
    - What part of my logic could fail?
        
    - What if this part gets a `null`, 0, or a very large input?
        

---

### 🔁 **Step 6: Dry Run Your Logic on Paper**

- Pick 1–2 sample test cases and **manually simulate** the algorithm step by step.
    
- Make sure your logic handles all cases as expected.
    

---

### ⌨️ **Step 7: Code Carefully**

- Translate your pseudocode into actual code.
    
- Write clean, readable code with good variable names.
    
- Test edge cases **as you code**, not just at the end.
    

---

### 🧪 **Step 8: Test Thoroughly**

- Run all test cases, including:
    
    - Edge cases you thought of in Step 2
        
    - Custom tricky test cases
        
- Check for runtime errors, infinite loops, wrong outputs
    

---

### 📊 **Step 9: Analyze Time and Space Complexity**

- Calculate worst-case **time complexity**.
    
- Analyze extra **space used**.
    
- Ask yourself: Can it be optimized?
    

---

### 🔁 **Optional Step 10: Optimize If Needed**

- If it doesn’t meet constraints, go back and rethink the approach.
    
- Consider trade-offs in time vs. space.
    

---

### 🧘 **Bonus Step: Reflect (After Solving)**

- What went well?
    
- What did you miss initially?
    
- How could this be reused for similar problems?
    

---

Would you like a printable version of this checklist to keep while practicing?